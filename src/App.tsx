import React, { useState, useEffect } from 'react'
import FlashCard, { Fact } from './components/FlashCard.tsx'
import InputAndKeypad from './components/InputAndKeypad'
import Summary from './components/Summary.tsx'
import { randomFact } from './utils/facts.ts'
import { loadFacts, saveFacts, startTraining, finishTraining, addFactToCurrentTraining, logSession, getCurrentTraining } from './services/storage';
import { supabase, recordFactResponse, initializeSession } from './services/supabase';
import { clearAllLocalStorage } from './utils/debug'; // –ò–º–ø–æ—Ä—Ç–∏—Ä–∞–º–µ —Ñ—É–Ω–∫—Ü–∏—è—Ç–∞ –∑–∞ –∏–∑—á–∏—Å—Ç–≤–∞–Ω–µ –Ω–∞ –¥–∞–Ω–Ω–∏—Ç–µ
import dragonPic from '../Pics/Dragon 1.png'

const TARGET_SCORE = 300 // –º–æ–∂–µ—à –¥–∞ —Å–º–µ–Ω–∏—à –ø–æ –∂–µ–ª–∞–Ω–∏–µ
const POINT_CORRECT = 10
const POINT_WRONG = -5

import PuzzleSVG from './components/PuzzleSVG';
import Dashboard from './components/Dashboard';

export default function App() {
  const [score, setScore] = useState(0)
  const [fact, setFact] = useState<Fact>(() => randomFact())
  const [isFinished, setFinished] = useState(false)
  const [paused, setPaused] = useState(false)
  const [lastCorrect, setLastCorrect] = useState(null)
  const [puzzleRevealedCount, setPuzzleRevealedCount] = useState(0);
  const [showDashboard, setShowDashboard] = useState(false);
  const progressRef = React.useRef<HTMLDivElement>(null);
  const [progressWidth, setProgressWidth] = React.useState(0);
  React.useEffect(() => {
    if (progressRef.current) {
      setProgressWidth(progressRef.current.offsetWidth);
    }
    const handleResize = () => {
      if (progressRef.current) setProgressWidth(progressRef.current.offsetWidth);
    };
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  useEffect(() => {
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–∞–º–µ Supabase –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–∏—Ä–∞–Ω–µ –Ω–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ—Ç–æ
    const initializeApp = async () => {
      startTraining(); // —Å—Ç–∞—Ä—Ç–∏—Ä–∞–º–µ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∞ –ø—Ä–∏ –ø—ä—Ä–≤–æ–Ω–∞—á–∞–ª–Ω–æ –∑–∞—Ä–µ–∂–¥–∞–Ω–µ
      try {
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–∞–º–µ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—Å–∫–∞ —Å–µ—Å–∏—è, –∞–∫–æ –≤—ä–∑–º–æ–∂–Ω–æ
        const isAuthenticated = await initializeSession();
        
        if (!isAuthenticated) {
          console.warn('–ù–µ –º–æ–∂–µ –¥–∞ —Å–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–∞ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—Å–∫–∞ —Å–µ—Å–∏—è, –ø—Ä–æ–¥—ä–ª–∂–∞–≤–∞–º–µ –≤ –æ—Ñ–ª–∞–π–Ω —Ä–µ–∂–∏–º');
        }
      } catch (error) {
        console.error('–ì—Ä–µ—à–∫–∞ –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–∞–Ω–µ –Ω–∞ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—Å–∫–∞ —Å–µ—Å–∏—è:', error);
      }
      
      // –ó–∞—Ä–µ–∂–¥–∞–º–µ —Ñ–∞–∫—Ç–∏—Ç–µ –æ—Ç localStorage –∏ Supabase
      // –¢–∞–∑–∏ —Ñ—É–Ω–∫—Ü–∏—è —â–µ —Å–µ –ø–æ–≥—Ä–∏–∂–∏ –∑–∞ –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –≤—Ä—ä–∑–∫–∞—Ç–∞ –∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
      loadFacts();
    };
    
    initializeApp();
  }, [])

  const handleSubmit = (ok, duration, timedOut) => {
    setLastCorrect(ok);
    if (timedOut) {
      setPaused(true);
      return;
    }
    
    // –ù–µ –∏–∑–ø–æ–ª–∑–≤–∞–º–µ recordFactResponse –∑–∞ –∑–∞–ø–∏—Å –Ω–∞ —Å–µ—Å–∏–∏, —Ç—ä–π –∫–∞—Ç–æ –Ω–µ —Å–µ –∏–Ω—Ç–µ—Ä–µ—Å—É–≤–∞–º–µ –æ—Ç —Ç—è—Ö
    // –¢—Ä—É–¥–Ω–æ—Å—Ç—Ç–∞ —â–µ —Å–µ –æ–±–Ω–æ–≤–∏ –ª–æ–∫–∞–ª–Ω–æ –∏ —â–µ —Å–µ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–∞ —Å—ä—Å Supabase –ø—Ä–∏ —Å–ª–µ–¥–≤–∞—â–∞—Ç–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è
    // –ó–∞—Ä–µ–∂–¥–∞–º–µ —Ñ–∞–∫—Ç–∏—Ç–µ, –∑–∞ –¥–∞ –≤–∑–µ–º–µ–º –∞–∫—Ç—É–∞–ª–Ω–∞—Ç–∞ —Ç—Ä—É–¥–Ω–æ—Å—Ç
    const allFacts = loadFacts();
    const existingFact = allFacts.find(f => f.i === fact.i && f.j === fact.j);
    const currentDifficulty = existingFact?.difficultyRating || 5.0;
  
    // –î–æ–±–∞–≤–∏ –æ—Ç–≥–æ–≤–æ—Ä–∞ –∫—ä–º —Ç–µ–∫—É—â–∞—Ç–∞ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∞ —Å–∞–º–æ –∞–∫–æ timedOut –µ false
    addFactToCurrentTraining({
      fact: {
        i: fact.i,
        j: fact.j,
        correctCount: existingFact?.correctCount || 0,
        wrongCount: existingFact?.wrongCount || 0,
        streak: existingFact?.streak || 0,
        avgTime: existingFact?.avgTime || 0,
        attempts: existingFact?.attempts || 0,
        box: existingFact?.box || 1,
        lastPracticed: existingFact?.lastPracticed || new Date().toISOString(),
        nextPractice: existingFact?.nextPractice || new Date().toISOString(),
        difficultyRating: currentDifficulty // –ò–∑–ø–æ–ª–∑–≤–∞–º–µ –∞–∫—Ç—É–∞–ª–Ω–∞—Ç–∞ —Ç—Ä—É–¥–Ω–æ—Å—Ç –Ω–∞ —Ñ–∞–∫—Ç–∞
      },
      isCorrect: ok,
      responseTime: duration
    });
    setPuzzleRevealedCount(prev => {
      if (ok) return Math.min(prev + 2, 60);
      else return Math.max(prev - 1, 0);
    });
    setScore(s => {
      const next = s + (ok ? POINT_CORRECT : POINT_WRONG)
      // update statistics for this fact
      const prevFacts = loadFacts()
      const existing = prevFacts.find(f => f.i === fact.i && f.j === fact.j)
      const daysMap: Record<number, number> = {1: 0, 2: 1, 3: 2, 4: 4, 5: 7};

      const record = existing
        ? { ...existing } 
        : { 
            i: fact.i,
            j: fact.j,
            correctCount: 0,
            wrongCount: 0,
            streak: 0,
            avgTime: 0,
            attempts: 0,
            box: 1,
            lastPracticed: new Date().toISOString(),
            nextPractice: new Date(Date.now() + daysMap[1] * 86400000).toISOString(),
            difficultyRating: 5.0  // –î–æ–±–∞–≤—è–º–µ —Å—Ç–æ–π–Ω–æ—Å—Ç –ø–æ –ø–æ–¥—Ä–∞–∑–±–∏—Ä–∞–Ω–µ
          };

      // Update stats based on correctness
      const now = new Date().toISOString();
      // update metrics
      record.attempts = (record.attempts ?? 0) + 1
      if (ok) {
        record.correctCount = (record.correctCount ?? 0) + 1
        record.streak = (record.streak ?? 0) + 1
      } else {
        record.wrongCount = (record.wrongCount ?? 0) + 1
        record.streak = 0
      }
      record.avgTime = ((record.avgTime ?? 0) * (record.attempts - 1) + duration) / record.attempts
      
      // –ê–∫—Ç—É–∞–ª–∏–∑–∏—Ä–∞–º–µ —Ç—Ä—É–¥–Ω–æ—Å—Ç—Ç–∞ –Ω–∞ —Ñ–∞–∫—Ç–∞ –≤ –ª–æ–∫–∞–ª–Ω–∏—è storage –ø–æ —Å—ä—â–∏—è –Ω–∞—á–∏–Ω –∫–∞–∫—Ç–æ –≤ Supabase
      record.difficultyRating = Math.max(1, Math.min(10, (record.difficultyRating || 5.0) + (ok ? -0.2 : 0.5)))
      // Leitner system: update box and lastPracticed
      if (ok && record.streak >= 3) {
        record.box = Math.min((record.box ?? 1) + 1, 5);
        record.lastPracticed = now;
      } else if (!ok) {
        record.box = 1;
        record.lastPracticed = now;
      }
      // update nextPractice based on interval
      record.nextPractice = new Date(Date.now() + daysMap[record.box] * 86400000).toISOString();
      // save updated stats
      const updatedFacts = [...prevFacts.filter(f => !(f.i === fact.i && f.j === fact.j)), record] 
      saveFacts(updatedFacts)
      if (next >= TARGET_SCORE) {
        setFinished(true)
        finishTraining(); // –ü—Ä–∏ –¥–æ—Å—Ç–∏–≥–∞–Ω–µ –Ω–∞ —Ü–µ–ª—Ç–∞ –ø—Ä–∏–∫–ª—é—á–∏ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∞—Ç–∞
      }
      // –°—ä–∑–¥–∞–≤–∞–º–µ –∏ –∑–∞–ø–∏—Å–≤–∞–º–µ —Å–µ—Å–∏—è—Ç–∞ –≤ Supabase
      logSession({
        id: Date.now().toString(),
        startTime: new Date().toISOString(),
        endTime: new Date().toISOString(),
        score: next,
        durationSeconds: Math.floor(duration / 1000), // –ø—Ä–µ–≤—Ä—ä—â–∞–º–µ –º–∏–ª–∏—Å–µ–∫—É–Ω–¥–∏—Ç–µ –≤ —Å–µ–∫—É–Ω–¥–∏
        timedOut,
        facts: [{ // –∏–∑–ø–æ–ª–∑–≤–∞–º–µ –Ω–æ–≤–∏—è FactResponse —Ç–∏–ø
          fact: {
            i: fact.i,
            j: fact.j,
            correctCount: record.correctCount, // –ò–∑–ø–æ–ª–∑–≤–∞–º–µ –∞–∫—Ç—É–∞–ª–Ω–∏—Ç–µ —Å—Ç–æ–π–Ω–æ—Å—Ç–∏ –æ—Ç —Ñ–∞–∫—Ç–∞
            wrongCount: record.wrongCount,
            streak: record.streak,
            avgTime: record.avgTime,
            attempts: record.attempts,
            box: record.box,
            lastPracticed: record.lastPracticed,
            nextPractice: record.nextPractice,
            difficultyRating: record.difficultyRating // –ò–∑–ø–æ–ª–∑–≤–∞–º–µ –∞–∫—Ç—É–∞–ª–Ω–∞—Ç–∞ —Ç—Ä—É–¥–Ω–æ—Å—Ç
          },
          isCorrect: ok,
          responseTime: duration
        }]
      })
      return next
    })
    setFact(randomFact())
  }

  const restart = () => {
    setScore(0)
    setFact(randomFact())
    setFinished(false)
    setPaused(false);
    startTraining(); // –ü—Ä–∏ —Ä–µ—Å—Ç–∞—Ä—Ç –∑–∞–ø–æ—á–Ω–∏ –Ω–æ–≤–∞ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∞
  }

  if (showDashboard) {
    return <Dashboard onClose={() => setShowDashboard(false)} />
  }

  if (paused) {
    return (
      <div className="min-h-screen flex flex-col items-center justify-center gap-6">
        <div className="text-2xl">–í—Ä–µ–º–µ—Ç–æ –∏–∑—Ç–µ—á–µ!</div>
        <div className="flex gap-4">
          <button onClick={() => { setPaused(false); setFact(randomFact()) }} className="bg-blue-500 text-white px-4 py-2 rounded">
            –ü—Ä–æ–¥—ä–ª–∂–∏
          </button>
          <button onClick={() => { setPaused(false); setFinished(true); finishTraining(); }} className="bg-red-500 text-white px-4 py-2 rounded">
            –ö—Ä–∞–π –Ω–∞ –∏–≥—Ä–∞—Ç–∞
          </button>
        </div>
      </div>
    )
  }
  if (isFinished) return <Summary score={score} onRestart={restart} />

  return (
    <div className="app-wrapper">
      {/* –†–æ–¥–∏—Ç–µ–ª—Å–∫–∏ –∫–æ–Ω—Ç—Ä–æ–ª–µ–Ω –±—É—Ç–æ–Ω */}
      <button 
        onClick={() => setShowDashboard(true)}
        className="absolute top-4 right-4 z-50 px-3 py-2 bg-purple-600 text-white rounded-full hover:bg-purple-700 focus:outline-none flex items-center justify-center shadow-lg"
        title="–†–æ–¥–∏—Ç–µ–ª—Å–∫–∏ –¥–∞—à–±–æ—Ä–¥"
      >
        <span className="text-xl">üìä</span>
      </button>
      {/* progress bar */}
      <div className="progress-container" ref={progressRef} style={{position:'relative'}}>
        <div
          className="progress-bar"
          style={{ 
            width: `${Math.min((score / TARGET_SCORE) * 100, 100)}%`,
            background: lastCorrect === null
              ? 'linear-gradient(to right, #3b82f6, #60a5fa)'
              : lastCorrect
                ? 'linear-gradient(to right, #3b82f6, #60a5fa)'
                : 'linear-gradient(to right, #f97316, #fb923c)'
          }}
        />
        <span className="progress-text">
          {Math.round((score / TARGET_SCORE) * 100)}%
        </span>
        {/* Emoji indicator - –∞–±—Å–æ–ª—é—Ç–Ω–æ —Å–ø—Ä—è–º–æ progress-container */}
        <span
          className="progress-emoji"
          style={{
            position: 'absolute',
            left: progressWidth
              ? `calc(${Math.max(0, Math.min((score / TARGET_SCORE), 1)) * progressWidth}px)`
              : '0px',
            top: '50%',
            transform: 'translate(-50%,-50%)',
            fontSize: '4.0rem',
            pointerEvents: 'none',
            zIndex: 20,
            transition: 'left 0.5s cubic-bezier(.4,0,.2,1)'
          }}
        >
          {lastCorrect === null ? '' : lastCorrect ? 'üòú' : 'üòí'}
        </span>
      </div>

      {/* three-panel layout, —Ç–æ—á–Ω–æ –∫–∞—Ç–æ –≤ mockup Grisho.html */}
      <div className="main-content">
        {/* –õ—è–≤ –ø–∞–Ω–µ–ª - –ø—ä–∑–µ–ª */}
        <div className="left-panel">
          <div className="puzzle-placeholder">
            {/* –¢—É–∫ —â–µ —Å–ª–æ–∂–∏–º canvas –∏–ª–∏ SVG –∑–∞ –ø—ä–∑–µ–ª–∞ –≤ –±—ä–¥–µ—â–µ */}
          </div>
          <PuzzleSVG revealedCount={puzzleRevealedCount} />
        </div>
        {/* –¶–µ–Ω—Ç—Ä–∞–ª–µ–Ω –ø–∞–Ω–µ–ª - —Å–∞–º–æ –∑–∞–¥–∞—á–∞—Ç–∞ */}
        <div className="flash-card-panel">
          <div className="problem" id="problem">
            {fact.i} √ó {fact.j}
          </div>
        </div>
        {/* –î–µ—Å–µ–Ω –ø–∞–Ω–µ–ª - input –∏ keypad */}
        <div className="right-panel flex flex-col items-center gap-4">
          <InputAndKeypad onSubmit={handleSubmit} correctAnswer={fact.i * fact.j} fact={fact} />
        </div>
      </div>
    </div>
  )
}
